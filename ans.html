<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet" />

  <style>
    body { background: white; margin: 0; padding: 0; }
    #stop-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      font-size: 16px;
      background: #d9534f;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: none;
      z-index: 9999;
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button" type="button">Stop Task</button>

<script>
/* =======================
   REQUIRED LINKS (EDITED)
   ======================= */
const DATA_ENDPOINT =
  "https://script.google.com/macros/s/AKfycbw13aJQQSF-uMwviOHrDCFGkPd57qozYNkiPTDNB5m9EmrmP3EvNK7PGNhQCGNwhxkx/exec";

const QUALTRICS_RETURN_URL =
  "https://brown.co1.qualtrics.com/jfe/form/SV_9KPQJgVkpEZkhN4";

/* =======================
   PID FROM QUALTRICS
   ======================= */
const params = new URLSearchParams(window.location.search);
const pid = params.get("pid") || "NO_PID";

/* =======================
   TASK PARAMETERS
   ======================= */
const taskDurationMinutes = 5;
const taskEndTime = Date.now() + taskDurationMinutes * 60 * 1000;

const responseKeys = ['f','j'];

const fixationDuration = 400;  // ms
const stimDuration = 700;      // ms (dots visible)
const isiDuration = 250;       // ms

/* canvas / dots */
const canvasSize = { w: 1000, h: 500 };
const dividerMargin = 20;
const leftArea  = { x: 0, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
const rightArea = { x: (canvasSize.w/2) + dividerMargin, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };

const dotRadiusRange = [4, 10];
const minDotSpacing = 2;

const numerosityMin = 6;
const numerosityMax = 30;

/* =======================
   GLOBAL STATE
   ======================= */
let attempted = 0;
let correct = 0;

/* we store the current trial info here so response trial can score it */
let currentTrial = null;

/* =======================
   SEND DATA TO GOOGLE
   ======================= */
function sendTrialData(row) {
  try {
    fetch(DATA_ENDPOINT, {
      method: "POST",
      body: JSON.stringify(row),
      headers: { "Content-Type": "application/json" }
    });
  } catch (e) {}
}

/* =======================
   DOT HELPERS
   ======================= */
function rint(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function generateDotPositions(count, bbox, radiiRange, minSpacing, maxAttemptsPerDot=200) {
  const dots = [];
  const minR = radiiRange[0];
  const maxR = radiiRange[1];

  for (let i = 0; i < count; i++) {
    let placed = false;
    let attempts = 0;

    while (!placed && attempts < maxAttemptsPerDot) {
      attempts++;
      const r = rint(minR, maxR);

      const minX = bbox.x + r;
      const maxX = bbox.x + bbox.w - r;
      const minY = bbox.y + r;
      const maxY = bbox.y + bbox.h - r;

      if (minX > maxX || minY > maxY) continue;

      const x = rint(Math.ceil(minX), Math.floor(maxX));
      const y = rint(Math.ceil(minY), Math.floor(maxY));

      let ok = true;
      for (const d of dots) {
        const dx = d.x - x;
        const dy = d.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < (d.r + r + minSpacing)) { ok = false; break; }
      }

      if (ok) {
        dots.push({ x, y, r });
        placed = true;
      }
    }

    // fallback: if crowded, just place a small dot in the center-ish
    if (!placed) {
      dots.push({
        x: bbox.x + bbox.w/2 + rint(-20, 20),
        y: bbox.y + bbox.h/2 + rint(-20, 20),
        r: minR
      });
    }
  }

  return dots;
}

function makeTrial() {
  // pick counts; avoid ties
  let left = rint(numerosityMin, numerosityMax);
  let right = rint(numerosityMin, numerosityMax);
  while (left === right) right = rint(numerosityMin, numerosityMax);

  const leftDots = generateDotPositions(left, leftArea, dotRadiusRange, minDotSpacing);
  const rightDots = generateDotPositions(right, rightArea, dotRadiusRange, minDotSpacing);

  return { left, right, leftDots, rightDots };
}

/* =======================
   jsPsych SETUP
   ======================= */
jsPsych.data.addProperties({ pid });

const timeline = [];

/* -------- Instructions -------- */
timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h3>Number Task</h3>
    <p>Two groups of dots will appear briefly.</p>
    <p>Press <strong>F</strong> if the LEFT side has more dots.</p>
    <p>Press <strong>J</strong> if the RIGHT side has more dots.</p>
    <p>You may stop at any time using the red button.</p>
    <p><em>Press any key to begin.</em></p>
  `,
  on_finish: () => {
    document.getElementById("stop-button").style.display = "block";
  }
});

/* -------- Trial (fixation -> dots -> ISI -> response) -------- */
const oneTrial = [
  {
    type: "html-keyboard-response",
    stimulus: '<div style="font-size:90px; display:flex; justify-content:center; align-items:center; height:60vh;">+</div>',
    choices: jsPsych.NO_KEYS,
    trial_duration: fixationDuration
  },
  {
    type: "canvas-keyboard-response",
    canvas_size: [canvasSize.w, canvasSize.h],

    // IMPORTANT: jsPsych v6 expects stimulus() returning a draw function(canvas)
    stimulus: function() {
      currentTrial = makeTrial();

      return function(c) {
        const ctx = c.getContext("2d");
        ctx.clearRect(0,0,c.width,c.height);

        // background
        ctx.fillStyle = "white";
        ctx.fillRect(0,0,c.width,c.height);

        // divider
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(c.width/2, 0);
        ctx.lineTo(c.width/2, c.height);
        ctx.stroke();

        // dots
        ctx.fillStyle = "black";
        for (const d of currentTrial.leftDots) {
          ctx.beginPath();
          ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
          ctx.fill();
        }
        for (const d of currentTrial.rightDots) {
          ctx.beginPath();
          ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
          ctx.fill();
        }
      };
    },

    choices: jsPsych.NO_KEYS,
    trial_duration: stimDuration
  },
  {
    type: "html-keyboard-response",
    stimulus: "<div></div>",
    choices: jsPsych.NO_KEYS,
    trial_duration: isiDuration
  },
  {
    type: "html-keyboard-response",
    stimulus: `
      <div style="text-align:center;">
        <p style="font-size:18px;">Which side had more dots?</p>
        <p style="font-size:18px;"><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
      </div>
    `,
    choices: responseKeys,
    on_finish: function(data) {
      attempted++;

      const left = currentTrial.left;
      const right = currentTrial.right;

      const isCorrect =
        (left > right && data.response === 'f') ||
        (right > left && data.response === 'j');

      if (isCorrect) correct++;

      sendTrialData({
        pid,
        event: "TRIAL",
        attempted,
        left,
        right,
        response: data.response,
        accuracy: isCorrect ? 1 : 0,
        rt: data.rt,
        timestamp: Date.now()
      });
    }
  }
];

/* -------- Trial Loop -------- */
const trialLoop = {
  timeline: oneTrial,
  loop_function: () => Date.now() < taskEndTime
};

timeline.push(trialLoop);

/* -------- End + Redirect -------- */
timeline.push({
  type: "html-keyboard-response",
  stimulus: "<p style='text-align:center;'>Task complete. Returning to surveyâ€¦</p>",
  choices: jsPsych.NO_KEYS,
  trial_duration: 300,
  on_start: () => {
    const engagement = correct;
    const persistence = attempted > 0 ? correct / attempted : 0;

    const url =
      QUALTRICS_RETURN_URL +
      "?ans_done=1" +
      "&pid=" + encodeURIComponent(pid) +
      "&attempted=" + encodeURIComponent(attempted) +
      "&correct=" + encodeURIComponent(correct) +
      "&engagement=" + encodeURIComponent(engagement) +
      "&persistence=" + encodeURIComponent(persistence);

    window.location.assign(url);
  }
});

/* -------- INIT -------- */
jsPsych.init({
  timeline: timeline,
  display_element: "jspsych-target",
  on_finish: function() {
    // safety: if something ends unexpectedly, still return
    if (Date.now() >= taskEndTime) return;
  }
});

/* -------- STOP BUTTON -------- */
document.getElementById("stop-button").onclick = () => {
  const engagement = correct;
  const persistence = attempted > 0 ? correct / attempted : 0;

  const url =
    QUALTRICS_RETURN_URL +
    "?ans_done=0" +
    "&pid=" + encodeURIComponent(pid) +
    "&attempted=" + encodeURIComponent(attempted) +
    "&correct=" + encodeURIComponent(correct) +
    "&engagement=" + encodeURIComponent(engagement) +
    "&persistence=" + encodeURIComponent(persistence);

  window.location.assign(url);
};
</script>
</body>
</html>
