<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ANS Task</title>

  <!-- jsPsych core -->
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet">

  <!-- Plugins -->
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>

  <style>
    body { background: #fff; }
    #stop-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #d9534f;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      z-index: 9999;
      display: none;
    }
    #stop-button:hover { background-color: #c9302c; }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button">Stop Task</button>

  <script>
    // ===========================
    // Qualtrics ID hookup
    // ===========================
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('pid') || 'no_pid';

    // Add pid to ALL rows
    jsPsych.data.addProperties({ pid });

    // ===========================
    // Safe return to Qualtrics
    // ===========================
    function returnToQualtrics(paramsObj) {
      const base = document.referrer; // Qualtrics page that opened this tab

      // If someone tests by typing the URL directly, referrer can be empty.
      if (!base) {
        document.body.innerHTML = `
          <div style="max-width:760px;margin:40px auto;font-family:Arial;text-align:center;">
            <h2>All set!</h2>
            <p>Please close this tab and return to the survey tab to continue.</p>
          </div>`;
        return;
      }

      const url = new URL(base);
      Object.entries(paramsObj || {}).forEach(([k, v]) => url.searchParams.set(k, v));
      window.location.replace(url.toString());
    }

    // ===========================
    // Task Parameters
    // ===========================
    const requiredMinutes = 1;          // REQUIRED portion
    const maxTotalMinutes = 10;         // cap (optional portion)
    const stimDuration = 1000;          // ms
    const fixationDuration = 500;       // ms
    const isiDuration = 250;            // ms
    const canvasSize = { w: 1200, h: 600 };
    const dividerMargin = 20;
    const leftArea  = { x: 0, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const rightArea = { x: (canvasSize.w/2) + dividerMargin, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const dotRadiusRange = [4, 12];
    const minDotSpacing = 2;
    const numerosityRange = [6, 40];
    const ratios = [1.1, 1.2, 1.5, 2];
    const responseKeys = ['f','j']; // f=left j=right

    // Timing control
    let shouldStopTask = false;
    let timerInterval = null;
    let minuteStartTime = null;
    let minuteEndTime = null;

    // Trial state
    let lastSpec = null;

    // Helpers
    function rint(min, max) { return Math.floor(Math.random()*(max-min+1)) + min; }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function generateDotPositions(count, bbox, radiiRange, minSpacing, maxAttemptsPerDot=300) {
      const dots = [];
      const maxR = radiiRange[1];
      const minR = radiiRange[0];

      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < maxAttemptsPerDot) {
          attempts++;
          const r = rint(minR, maxR);

          const minX = bbox.x + r;
          const maxX = bbox.x + bbox.w - r;
          const minY = bbox.y + r;
          const maxY = bbox.y + bbox.h - r;
          if (minX > maxX || minY > maxY) continue;

          const x = rint(Math.ceil(minX), Math.floor(maxX));
          const y = rint(Math.ceil(minY), Math.floor(maxY));

          let ok = true;
          for (const d of dots) {
            const dx = d.x - x;
            const dy = d.y - y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < (d.r + r + minSpacing)) { ok = false; break; }
          }

          if (ok) { dots.push({x, y, r}); placed = true; }
        }

        if (!placed) {
          // last resort: drop a tiny dot in the center of bbox
          const r = minR;
          const centerX = bbox.x + bbox.w / 2;
          const centerY = bbox.y + bbox.h / 2;
          dots.push({x: centerX, y: centerY, r});
        }
      }

      return dots;
    }

    function makeTrial() {
      const ratio = choice(ratios);
      let base = rint(numerosityRange[0], numerosityRange[1]);
      let larger = Math.round(base * ratio);

      // clamp so larger stays in range
      if (larger > numerosityRange[1]) {
        base = Math.floor(numerosityRange[1] / ratio);
        larger = Math.round(base * ratio);
      }
      if (larger < numerosityRange[0]) {
        base = Math.ceil(numerosityRange[0] / ratio);
        larger = Math.round(base * ratio);
      }

      base = Math.max(numerosityRange[0], Math.min(numerosityRange[1], base));
      larger = Math.max(numerosityRange[0], Math.min(numerosityRange[1], larger));

      const leftIsLarger = Math.random() < 0.5;
      const leftCount  = leftIsLarger ? larger : base;
      const rightCount = leftIsLarger ? base : larger;

      return {
        leftCount,
        rightCount,
        ratio: (leftCount>rightCount) ? (leftCount/rightCount) : (rightCount/leftCount),
        largerSide: leftIsLarger ? 'left' : 'right',
        leftDots: generateDotPositions(leftCount, leftArea, dotRadiusRange, minDotSpacing),
        rightDots: generateDotPositions(rightCount, rightArea, dotRadiusRange, minDotSpacing)
      };
    }

    function startMinuteTimer() {
      minuteStartTime = Date.now();
      minuteEndTime = minuteStartTime + 60*1000;
      shouldStopTask = false;

      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (Date.now() >= minuteEndTime) {
          clearInterval(timerInterval);
          jsPsych.endCurrentTimeline(); // ends the looping trial timeline for this minute
        }
      }, 100);
    }

    function minuteLoopContinue() {
      return !shouldStopTask && Date.now() < minuteEndTime;
    }

    // ===========================
    // Build one "minute" of trials
    // ===========================
    function buildOneMinuteLoop() {
      const minuteLoop = {
        timeline: [
          // fixation
          {
            type: 'html-keyboard-response',
            stimulus: '<div style="font-size:90px;display:flex;justify-content:center;align-items:center;height:50vh;">+</div>',
            choices: jsPsych.NO_KEYS,
            trial_duration: fixationDuration,
            data: { phase: 'fixation' }
          },
          // stimulus
          {
            type: 'canvas-keyboard-response',
            canvas_size: [canvasSize.w, canvasSize.h],
            stimulus: function(c) {
              const spec = makeTrial();
              lastSpec = spec;

              const ctx = c.getContext('2d');
              ctx.clearRect(0,0,c.width,c.height);
              ctx.fillStyle = 'white';
              ctx.fillRect(0,0,c.width,c.height);

              ctx.strokeStyle = '#cccccc';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(c.width/2, 0);
              ctx.lineTo(c.width/2, c.height);
              ctx.stroke();

              ctx.fillStyle = 'black';
              for (const d of spec.leftDots){
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
                ctx.fill();
              }
              for (const d of spec.rightDots){
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
                ctx.fill();
              }
            },
            choices: jsPsych.NO_KEYS,
            trial_duration: stimDuration,
            data: { trial_type: 'stimulus' }
          },
          // ISI
          {
            type: 'html-keyboard-response',
            stimulus: '<div></div>',
            choices: jsPsych.NO_KEYS,
            trial_duration: isiDuration,
            data: { phase: 'isi' }
          },
          // response
          {
            type: 'html-keyboard-response',
            stimulus: `
              <div style="font-size:18px;text-align:center;">
                <p>Which side had more dots?</p>
                <p><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
                <p style="font-size:14px;color:gray;">Press F or J.</p>
              </div>
            `,
            choices: responseKeys,
            response_ends_trial: true,
            data: { trial_type: 'response' },
            on_start: function(trial) {
              if (lastSpec) {
                trial.data.leftCount = lastSpec.leftCount;
                trial.data.rightCount = lastSpec.rightCount;
                trial.data.ratio = lastSpec.ratio;
                trial.data.largerSide = lastSpec.largerSide;
              }
            },
            on_finish: function(data) {
              const key = data.response;
              const left = data.leftCount;
              const right = data.rightCount;

              let correct = 0;
              if (left > right && key === 'f') correct = 1;
              if (right > left && key === 'j') correct = 1;

              data.accuracy = correct;
              data.choice = (key === 'f' ? 'left' : 'right');
            }
          }
        ],
        loop_function: function() {
          return minuteLoopContinue();
        }
      };

      return minuteLoop;
    }

    // ===========================
    // Build full task timeline
    // ===========================
    const timeline = [];

    // Instructions
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `
        <h3>Number Task</h3>
        <p>Two dot arrays will flash briefly (left and right). After a short delay, press <strong>F</strong> if the <strong>left</strong> side had more dots, or <strong>J</strong> if the <strong>right</strong> side had more dots.</p>
        <p>Try to be both fast and accurate.</p>
        <p><strong>Required:</strong> You will complete 1 minute of trials.</p>
        <p><strong>Optional:</strong> After that, you may choose to continue for additional optional minutes (up to ${maxTotalMinutes} minutes total).</p>
        <p><em>Press any key to begin.</em></p>
      `,
      choices: jsPsych.ALL_KEYS,
      on_finish: function() {
        document.getElementById('stop-button').style.display = 'block';
        document.getElementById('stop-button').onclick = function() {
          shouldStopTask = true;
          if (timerInterval) clearInterval(timerInterval);

          // Return to Qualtrics with done=0 (they ended early)
          returnToQualtrics({ ans_done: 0, pid: pid });
        };
      }
    });

    // Required 1 minute
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `<h3>Required Trials</h3><p>You will now complete the required portion (1 minute).</p><p><em>Press any key to start.</em></p>`,
      choices: jsPsych.ALL_KEYS,
      on_finish: function(){ startMinuteTimer(); }
    });
    timeline.push(buildOneMinuteLoop());

    // Optional minutes (up to maxTotalMinutes-1 more)
    let minutesCompleted = 1;

    const optionalBlock = {
      timeline: [
        {
          type: 'html-keyboard-response',
          stimulus: function(){
            return `
              <h3>Continue?</h3>
              <p>You have completed <strong>${minutesCompleted}</strong> minute(s).</p>
              <p>You may continue with an additional optional minute, or you may stop now.</p>
              <p><strong>Press C</strong> to continue &nbsp;&nbsp; | &nbsp;&nbsp; <strong>Press S</strong> to stop</p>
            `;
          },
          choices: ['c','s'],
          on_finish: function(data){
            data.continue_choice = data.response; // 'c' or 's'
            if (data.response === 's') {
              shouldStopTask = true;
              if (timerInterval) clearInterval(timerInterval);
              jsPsych.endCurrentTimeline(); // ends optional loop
            } else {
              // continue another minute
              minutesCompleted += 1;
              startMinuteTimer();
            }
          }
        },
        buildOneMinuteLoop()
      ],
      loop_function: function(){
        // allow loop while they haven't chosen stop AND haven't hit maxTotalMinutes
        return (!shouldStopTask) && (minutesCompleted < maxTotalMinutes);
      }
    };

    timeline.push(optionalBlock);

    // End screen
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `<h3>Thanks â€” task complete!</h3><p>Press any key to return to the survey.</p>`,
      choices: jsPsych.ALL_KEYS,
      on_start: function() {
        document.getElementById('stop-button').style.display = 'none';
        if (timerInterval) clearInterval(timerInterval);
      }
    });

    // Initialize jsPsych
    jsPsych.init({
      timeline: timeline,
      display_element: 'jspsych-target',
      on_finish: function() {
        // Summaries based on response trials
        const responses = jsPsych.data.get().filter({ trial_type: 'response' });
        const attempted = responses.count();
        const correct = responses.filter({ accuracy: 1 }).count();

        // Your definitions:
        const engagement = correct;
        const persistence = attempted > 0 ? (correct / attempted) : 0;

        // Return to Qualtrics with variables
        returnToQualtrics({
          ans_done: 1,
          pid: pid,
          engagement: engagement,
          persistence: persistence,
          attempted: attempted,
          correct: correct
        });
      }
    });
  </script>
</body>
</html>
