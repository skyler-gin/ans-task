<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />

  <!-- jsPsych v6.3.1 -->
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet" />

  <style>
    body { background: white; margin: 0; }
    #stop-button {
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 22px;
      font-size: 16px;
      background: #d9534f;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: none;
      z-index: 9999;
    }
    #stop-button:hover { filter: brightness(0.95); }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button">Stop Task</button>

<script>
/* =======================
   REQUIRED LINKS (YOU PROVIDED)
   ======================= */
const DATA_ENDPOINT =
  "https://script.google.com/macros/s/AKfycbw13aJQQSF-uMwviOHrDCFGkPd57qozYNkiPTDNB5m9EmrmP3EvNK7PGNhQCGNwhxkx/exec";

const QUALTRICS_RETURN_URL =
  "https://brown.co1.qualtrics.com/jfe/form/SV_9KPQJgVkpEZkhN4";

/* =======================
   PID FROM QUALTRICS
   ======================= */
const params = new URLSearchParams(window.location.search);
const pid = params.get("pid") || "NO_PID";

/* =======================
   TASK SETTINGS
   ======================= */
const REQUIRED_MINUTES = 1;          // required block length
const MAX_TOTAL_MINUTES = 10;        // hard cap if they keep opting in
const CHECKPOINT_EVERY_MIN = 1;      // ask each minute if they want to continue

const responseKeys = ['f','j'];      // F left, J right

// Timing (ms)
const fixationMs = 400;
const stimMs = 650;
const isiMs = 200;

// Canvas
const canvasW = 900;
const canvasH = 450;
const dividerMargin = 16;

const leftBox = { x: 0, y: 0, w: canvasW/2 - dividerMargin, h: canvasH };
const rightBox = { x: canvasW/2 + dividerMargin, y: 0, w: canvasW/2 - dividerMargin, h: canvasH };

const dotRadiusRange = [4, 10];
const numerosityRange = [6, 40];
const ratios = [1.1, 1.2, 1.5, 2];

/* =======================
   STATE
   ======================= */
let attempted = 0;
let correct = 0;
let lastSpec = null;

let taskStart = null;
let blockStart = null;
let requiredEnd = null;
let hardEnd = null;

let shouldStop = false;

/* =======================
   HELPERS
   ======================= */
function rint(min, max) { return Math.floor(Math.random()*(max-min+1)) + min; }
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function generateDots(count, bbox, radiiRange, maxAttemptsPerDot=250) {
  const dots = [];
  const minR = radiiRange[0], maxR = radiiRange[1];

  for (let i=0; i<count; i++){
    let placed=false;
    for (let a=0; a<maxAttemptsPerDot && !placed; a++){
      const r = rint(minR, maxR);
      const x = rint(Math.ceil(bbox.x + r), Math.floor(bbox.x + bbox.w - r));
      const y = rint(Math.ceil(bbox.y + r), Math.floor(bbox.y + bbox.h - r));

      let ok=true;
      for (const d of dots){
        const dx = d.x - x, dy = d.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < (d.r + r + 2)) { ok=false; break; }
      }
      if (ok){
        dots.push({x,y,r});
        placed=true;
      }
    }
    if (!placed){
      // fallback: still place something (rare)
      dots.push({x: bbox.x + bbox.w/2, y: bbox.y + bbox.h/2, r: minR});
    }
  }
  return dots;
}

function makeTrial() {
  const ratio = choice(ratios);

  let base = rint(numerosityRange[0], numerosityRange[1]);
  let larger = Math.round(base * ratio);

  // keep within bounds
  if (larger > numerosityRange[1]) {
    base = Math.floor(numerosityRange[1] / ratio);
    larger = Math.round(base * ratio);
  }
  if (larger < numerosityRange[0]) {
    base = Math.ceil(numerosityRange[0] / ratio);
    larger = Math.round(base * ratio);
  }

  base = Math.max(numerosityRange[0], Math.min(numerosityRange[1], base));
  larger = Math.max(numerosityRange[0], Math.min(numerosityRange[1], larger));

  const leftIsLarger = Math.random() < 0.5;
  const leftCount = leftIsLarger ? larger : base;
  const rightCount = leftIsLarger ? base : larger;

  return {
    leftCount,
    rightCount,
    largerSide: leftIsLarger ? "left" : "right",
    ratio: (leftCount>rightCount) ? leftCount/rightCount : rightCount/leftCount,
    leftDots: generateDots(leftCount, leftBox, dotRadiusRange),
    rightDots: generateDots(rightCount, rightBox, dotRadiusRange)
  };
}

/* =======================
   DATA SENDING (per trial)
   ======================= */
function sendRow(row){
  // fire-and-forget (keep it robust; don’t block the participant)
  fetch(DATA_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(row)
  }).catch(()=>{});
}

function sendFinalSummary(stoppedFlag){
  const engagement = correct; // as you defined it
  const persistence = attempted > 0 ? correct/attempted : 0;

  // send a final summary row too (optional but helpful)
  sendRow({
    pid,
    row_type: "summary",
    attempted,
    correct,
    engagement,
    persistence,
    stopped: stoppedFlag ? 1 : 0,
    timestamp: Date.now()
  });

  // redirect back to Qualtrics with summary params
  const url =
    QUALTRICS_RETURN_URL +
    "?pid=" + encodeURIComponent(pid) +
    "&ans_done=" + (stoppedFlag ? 0 : 1) +
    "&attempted=" + attempted +
    "&correct=" + correct +
    "&engagement=" + engagement +
    "&persistence=" + persistence +
    "&stopped=" + (stoppedFlag ? 1 : 0);

  window.location.assign(url);
}

/* =======================
   CONTROL: time + checkpoints
   ======================= */
function now(){ return Date.now(); }

function initTiming(){
  taskStart = now();
  blockStart = taskStart;
  requiredEnd = taskStart + REQUIRED_MINUTES*60000;
  hardEnd = taskStart + MAX_TOTAL_MINUTES*60000;
}

function inHardLimit(){ return now() < hardEnd; }

/* =======================
   jsPsych setup
   ======================= */
jsPsych.data.addProperties({ pid });

const timeline = [];

/* Instructions */
timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h3>Number Task</h3>
    <p>Two groups of dots will appear briefly.</p>
    <p>Press <strong>F</strong> if the <strong>LEFT</strong> side had more dots.</p>
    <p>Press <strong>J</strong> if the <strong>RIGHT</strong> side had more dots.</p>
    <p>You can stop at any time using the red <strong>Stop Task</strong> button.</p>
    <p><em>Press any key to begin.</em></p>
  `,
  on_finish: function(){
    initTiming();
    document.getElementById("stop-button").style.display = "block";
  }
});

/* One trial = fixation -> dots -> isi -> response */
function oneTrialTimeline(){
  return [
    {
      type: "html-keyboard-response",
      stimulus: '<div style="font-size:90px; display:flex; justify-content:center; align-items:center; height:50vh;">+</div>',
      choices: jsPsych.NO_KEYS,
      trial_duration: fixationMs,
      data: { phase: "fixation" }
    },
    {
      type: "canvas-keyboard-response",
      canvas_size: [canvasW, canvasH],
      stimulus: function(c){
        lastSpec = makeTrial();
        const ctx = c.getContext("2d");

        ctx.fillStyle = "white";
        ctx.fillRect(0,0,canvasW,canvasH);

        // divider
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(canvasW/2, 0);
        ctx.lineTo(canvasW/2, canvasH);
        ctx.stroke();

        // dots
        ctx.fillStyle = "black";
        lastSpec.leftDots.forEach(d=>{
          ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,2*Math.PI); ctx.fill();
        });
        lastSpec.rightDots.forEach(d=>{
          ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,2*Math.PI); ctx.fill();
        });
      },
      choices: jsPsych.NO_KEYS,
      trial_duration: stimMs,
      data: {
        phase: "stimulus"
      }
    },
    {
      type: "html-keyboard-response",
      stimulus: "<div></div>",
      choices: jsPsych.NO_KEYS,
      trial_duration: isiMs,
      data: { phase: "isi" }
    },
    {
      type: "html-keyboard-response",
      stimulus: `
        <div style="text-align:center; font-size:18px;">
          <p>Which side had more dots?</p>
          <p><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
        </div>
      `,
      choices: responseKeys,
      data: { trial_type: "response" },
      on_start: function(trial){
        if (lastSpec){
          trial.data.leftCount = lastSpec.leftCount;
          trial.data.rightCount = lastSpec.rightCount;
          trial.data.largerSide = lastSpec.largerSide;
          trial.data.ratio = lastSpec.ratio;
        }
      },
      on_finish: function(data){
        attempted++;

        const isCorrect =
          (data.leftCount > data.rightCount && data.response === "f") ||
          (data.rightCount > data.leftCount && data.response === "j");

        if (isCorrect) correct++;

        // send per-trial row
        sendRow({
          pid,
          row_type: "trial",
          attempted,
          correct,
          leftCount: data.leftCount,
          rightCount: data.rightCount,
          largerSide: data.largerSide,
          ratio: data.ratio,
          response: data.response,
          accuracy: isCorrect ? 1 : 0,
          rt: data.rt,
          timestamp: now()
        });
      }
    }
  ];
}

/* Loop that runs until (a) stop, (b) time checkpoint reached, or (c) hard cap */
const trialLoop = {
  timeline: oneTrialTimeline(),
  loop_function: function(){
    if (shouldStop) return false;
    if (!inHardLimit()) return false;

    // stop for checkpoint every minute (after required minute too)
    const elapsedMs = now() - blockStart;
    const checkpointMs = CHECKPOINT_EVERY_MIN * 60000;

    // If we reached a checkpoint, break to ask continue/stop
    if (elapsedMs >= checkpointMs) return false;

    return true;
  }
};

/* Checkpoint screen: after each minute */
timeline.push({
  timeline: [trialLoop],
  loop_function: function(){
    if (shouldStop) return false;
    if (!inHardLimit()) return false;

    // If still within hard limit, show checkpoint prompt:
    return true;
  }
});

timeline.push({
  type: "html-keyboard-response",
  choices: ['c','s'],
  stimulus: function(){
    const requiredDone = now() >= requiredEnd;

    // reset block timer for next minute chunk
    return `
      <h3>Continue?</h3>
      <p>You have completed <strong>${Math.floor((now()-taskStart)/60000)} minute(s)</strong> of the task.</p>

      ${requiredDone
        ? `<p><strong>Optional:</strong> You may continue with more trials, or stop now.</p>`
        : `<p><strong>Required:</strong> Please continue until you reach at least ${REQUIRED_MINUTES} minute(s).</p>`
      }

      <p><strong>Press C</strong> to continue.</p>
      <p><strong>Press S</strong> to stop.</p>
    `;
  },
  on_start: function(){
    // restart the 1-minute block window
    blockStart = now();
  },
  on_finish: function(data){
    const requiredDone = now() >= requiredEnd;

    if (data.response === 's' && requiredDone){
      shouldStop = true;
    } else if (data.response === 's' && !requiredDone){
      // ignore stop before required time is done
      shouldStop = false;
    } else {
      shouldStop = false;
    }

    // If they reached hard cap, force stop
    if (!inHardLimit()) shouldStop = true;
  }
});

/* End + redirect */
timeline.push({
  type: "html-keyboard-response",
  stimulus: "<p>Thanks — returning to the survey…</p>",
  choices: jsPsych.NO_KEYS,
  trial_duration: 250,
  on_start: function(){
    // stoppedFlag is 1 if they stopped AFTER required time or hit hard cap
    const stoppedFlag = (now() < hardEnd) ? 1 : 0; // if they stopped early voluntarily => 1
    sendFinalSummary(stoppedFlag);
  }
});

/* INIT */
jsPsych.init({
  timeline: timeline,
  display_element: "jspsych-target",
  on_finish: function(){
    // safety fallback (should already redirect in the end screen)
  }
});

/* STOP BUTTON (works anytime) */
document.getElementById("stop-button").onclick = function(){
  // allow stop immediately if required time has passed; otherwise require continuing
  if (now() >= requiredEnd){
    shouldStop = true;
    sendFinalSummary(1);
  } else {
    // If still required: show a gentle message
    alert("Please complete the required portion before stopping. Thank you!");
  }
};
</script>
</body>
</html>
