<!DOCTYPE html>
<html>
<head>
  <!-- jsPsych core -->
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet">

  <!-- Plugins -->
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>

  <style>
    #stop-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #d9534f;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      z-index: 9999;
      display: none;
    }
    #stop-button:hover { background-color: #c9302c; }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button">Stop Task</button>

  <script>
    // ===========================
    // Qualtrics ID hookup
    // ===========================
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('pid') || 'no_pid';

    // Attach pid to ALL rows of jsPsych data
    jsPsych.data.addProperties({ pid });

    // ===========================
    // ANS Task (jsPsych)
    // ===========================

    // ------- Parameters (tweak as needed) -------
    const taskDurationMinutes = 5;
    const taskDurationMs = taskDurationMinutes * 60 * 1000;
    const stimDuration = 1000;
    const fixationDuration = 500;
    const isiDuration = 250;

    const canvasSize = { w: 1200, h: 600 };
    const dividerMargin = 20;
    const leftArea = { x: 0, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const rightArea = { x: (canvasSize.w/2) + dividerMargin, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };

    const dotRadiusRange = [4, 12];
    const minDotSpacing = 2;
    const numerosityRange = [6, 40];
    const ratios = [1.1, 1.2, 1.5, 2];
    const responseKeys = ['f','j']; // f=left, j=right

    // Global variables for timing/control
    let taskStartTime = null;
    let taskEndTime = null;
    let shouldStopTask = false;
    let timerInterval = null;

    // Store most recent stimulus spec so the response trial can score it
    let lastSpec = null;

    function rint(min, max) {
      return Math.floor(Math.random()*(max-min+1)) + min;
    }

    function choice(arr){
      return arr[Math.floor(Math.random()*arr.length)];
    }

    function generateDotPositions(count, bbox, radiiRange, minSpacing, maxAttemptsPerDot=300) {
      const dots = [];
      const maxR = radiiRange[1];
      const minR = radiiRange[0];

      const safeMinX = bbox.x + maxR;
      const safeMaxX = bbox.x + bbox.w - maxR;
      const safeMinY = bbox.y + maxR;
      const safeMaxY = bbox.y + bbox.h - maxR;

      if (safeMinX >= safeMaxX || safeMinY >= safeMaxY) return [];

      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < maxAttemptsPerDot) {
          attempts++;

          const r = rint(minR, maxR);
          const minX = bbox.x + r;
          const maxX = bbox.x + bbox.w - r;
          const minY = bbox.y + r;
          const maxY = bbox.y + bbox.h - r;

          if (minX > maxX || minY > maxY) continue;

          const x = rint(Math.ceil(minX), Math.floor(maxX));
          const y = rint(Math.ceil(minY), Math.floor(maxY));

          let ok = true;
          for (const d of dots) {
            const dx = d.x - x;
            const dy = d.y - y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < (d.r + r + minSpacing)) { ok = false; break; }
          }

          if (ok) { dots.push({x, y, r}); placed = true; }
        }

        if (!placed) {
          // fallback: place a small dot in the center of bbox
          const r = minR;
          const centerX = bbox.x + bbox.w / 2;
          const centerY = bbox.y + bbox.h / 2;
          dots.push({x: centerX, y: centerY, r});
        }
      }
      return dots;
    }

    function makeTrial() {
      const ratio = choice(ratios);

      const baseMin = numerosityRange[0];
      const baseMax = numerosityRange[1];
      let base = rint(baseMin, baseMax);
      let larger = Math.round(base * ratio);

      if (larger < numerosityRange[0]) {
        base = Math.ceil(numerosityRange[0] / ratio);
        larger = Math.round(base * ratio);
      } else if (larger > numerosityRange[1]) {
        base = Math.floor(numerosityRange[1] / ratio);
        larger = Math.round(base * ratio);
      }

      base = Math.max(numerosityRange[0], Math.min(numerosityRange[1], base));
      larger = Math.max(numerosityRange[0], Math.min(numerosityRange[1], larger));

      const leftIsLarger = Math.random() < 0.5;
      const leftCount = leftIsLarger ? larger : base;
      const rightCount = leftIsLarger ? base : larger;

      const leftDots = generateDotPositions(leftCount, leftArea, dotRadiusRange, minDotSpacing);
      const rightDots = generateDotPositions(rightCount, rightArea, dotRadiusRange, minDotSpacing);

      return {
        leftCount,
        rightCount,
        ratio: (leftCount > rightCount) ? (leftCount / rightCount) : (rightCount / leftCount),
        largerSide: leftIsLarger ? 'left' : 'right',
        leftDots,
        rightDots
      };
    }

    function checkTimeLimit() {
      const now = Date.now();
      if (now >= taskEndTime) {
        shouldStopTask = true;
        clearInterval(timerInterval);
        jsPsych.endCurrentTimeline();
      }
    }

    function shouldContinueTask() {
      const now = Date.now();
      return !shouldStopTask && now < taskEndTime;
    }

    // ===========================
    // Timeline
    // ===========================
    const timeline = [];

    // Instructions
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `
        <h3>Approximate Number System (ANS) Task</h3>
        <p>Two dot arrays will flash briefly (left and right). After a short delay, press <strong>F</strong> if the <strong>left</strong> side had more dots, or <strong>J</strong> if the <strong>right</strong> side had more dots.</p>
        <p>Try to be both fast and accurate.</p>
        <p><strong>Duration:</strong> This task will run for ${taskDurationMinutes} minute${taskDurationMinutes > 1 ? 's' : ''}.</p>
        <p><em>Press any key to begin.</em></p>
      `,
      choices: jsPsych.ALL_KEYS,
      on_finish: function() {
        taskStartTime = Date.now();
        taskEndTime = taskStartTime + taskDurationMs;
        shouldStopTask = false;

        document.getElementById('stop-button').style.display = 'block';
        timerInterval = setInterval(checkTimeLimit, 100);

        document.getElementById('stop-button').onclick = function() {
          shouldStopTask = true;
          clearInterval(timerInterval);
          jsPsych.endCurrentTimeline(); // triggers jsPsych.init on_finish
          jsPsych.data.addProperties({ ans_done: 0 }); // mark as not completed
        };
      }
    });

    // Trial loop (runs until time is up)
    const trialLoop = {
      timeline: [],
      loop_function: function() { return shouldContinueTask(); }
    };

    trialLoop.timeline = [
      // fixation
      {
        type: 'html-keyboard-response',
        stimulus: '<div style="font-size:100px; display:flex; justify-content:center; align-items:center; height:50vh;">+</div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: fixationDuration,
        data: { phase: 'fixation' }
      },

      // stimulus
      {
        type: 'canvas-keyboard-response',
        canvas_size: [canvasSize.w, canvasSize.h],
        stimulus: function(c) {
          const spec = makeTrial();
          lastSpec = spec;

          const ctx = c.getContext('2d');
          ctx.clearRect(0,0,c.width,c.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0,0,c.width,c.height);

          ctx.strokeStyle = '#cccccc';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(c.width/2, 0);
          ctx.lineTo(c.width/2, c.height);
          ctx.stroke();

          ctx.fillStyle = 'black';
          for (const d of spec.leftDots){
            ctx.beginPath();
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }
          for (const d of spec.rightDots){
            ctx.beginPath();
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }
        },
        choices: jsPsych.NO_KEYS,
        trial_duration: stimDuration,
        data: { trial_type: 'stimulus' },
        on_finish: function(data) {
          if (lastSpec) {
            data.leftCount = lastSpec.leftCount;
            data.rightCount = lastSpec.rightCount;
            data.ratio = lastSpec.ratio;
            data.largerSide = lastSpec.largerSide;
          }
        }
      },

      // ISI
      {
        type: 'html-keyboard-response',
        stimulus: '<div></div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: isiDuration,
        data: { phase: 'isi' }
      },

      // response
      {
        type: 'html-keyboard-response',
        stimulus: `
          <div style="font-size:18px; text-align:center;">
            <p>Which side had more dots?</p>
            <p><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
          </div>
        `,
        choices: responseKeys,
        response_ends_trial: true,
        data: { trial_type: 'response' },
        on_start: function(trial) {
          if (lastSpec) {
            trial.data.leftCount = lastSpec.leftCount;
            trial.data.rightCount = lastSpec.rightCount;
            trial.data.ratio = lastSpec.ratio;
            trial.data.largerSide = lastSpec.largerSide;
          }
        },
        on_finish: function(data) {
          const key = data.response;
          const left = data.leftCount;
          const right = data.rightCount;

          let correct = 0;
          if (left > right && key === 'f') correct = 1;
          if (right > left && key === 'j') correct = 1;

          data.accuracy = correct;
          data.choice = (key === 'f' ? 'left' : (key === 'j' ? 'right' : 'none'));
        }
      }
    ];

    timeline.push(trialLoop);

    // End screen
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `<h3>Thanks â€” task complete!</h3><p>Press any key to return to the survey.</p>`,
      choices: jsPsych.ALL_KEYS,
      on_start: function() {
        document.getElementById('stop-button').style.display = 'none';
        clearInterval(timerInterval);
      }
    });

    // ===========================
    // Initialize jsPsych (ONLY place for summary + redirect)
    // ===========================
    jsPsych.init({
      timeline: timeline,
      display_element: 'jspsych-target',
      on_finish: function() {

        // If they never hit stop, mark complete
        const props = jsPsych.data.get().values()[0] || {};
        const ans_done = (props.ans_done === 0) ? 0 : 1;

        // Use only response trials
        const responses = jsPsych.data.get().filter({ trial_type: 'response' });
        const attempted = responses.count();
        const correct = responses.filter({ accuracy: 1 }).count();

        // Your constructs
        const engagement = correct; // # correct
        const persistence = attempted > 0 ? correct / attempted : 0; // proportion correct

        // Add to data
        jsPsych.data.addProperties({
          ans_done,
          attempted,
          correct,
          engagement,
          persistence
        });

        // OPTIONAL local save (pilot only)
        // jsPsych.data.localSave('csv', 'ans_data.csv');

        // Redirect back to Qualtrics (PUT YOUR REAL LINK HERE)
        const qlink = "https://YOURORG.qualtrics.com/jfe/form/SV_XXXXXXX";
        window.location.href =
          qlink +
          "?ans_done=" + ans_done +
          "&pid=" + encodeURIComponent(pid) +
          "&engagement=" + engagement +
          "&persistence=" + persistence;
      }
    });
  </script>
</body>
</html>
