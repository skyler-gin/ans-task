<!DOCTYPE html>
<html>
<head>
  <!-- jsPsych core -->
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet">

  <!-- Plugins -->
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>

  <style>
    #stop-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #d9534f;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      z-index: 9999;
      display: none;
    }
    #stop-button:hover {
      background-color: #c9302c;
    }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button">Stop Task</button>

  <script>
    // ===========================
    // Qualtrics ID hookup
    // ===========================
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('pid') || 'no_pid';

    // Attach pid to ALL rows of jsPsych data
    jsPsych.data.addProperties({ pid });

    // ===========================
    // ANS Task (jsPsych)
    // ===========================

    // ------- Parameters (tweak as needed) -------
    const taskDurationMinutes = 1; // Total task duration in minutes
    const taskDurationMs = taskDurationMinutes * 60 * 1000; // Convert to milliseconds
    const stimDuration = 1000; // ms - stimulus display time
    const fixationDuration = 500; // ms
    const isiDuration = 250; // ms between stimulus and response
    const canvasSize = { w: 1200, h: 600 }; // canvas width/height
    const dividerMargin = 20; // Keep dots this far from the center divider
    const leftArea = { x: 0, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const rightArea = { x: (canvasSize.w/2) + dividerMargin, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const dotRadiusRange = [4, 12]; // px
    const minDotSpacing = 2; // px extra gap between dot edges (smaller -> more dense)
    const numerosityRange = [6, 40]; // possible base numerosities
    const ratios = [1.1, 1.2, 1.5, 2]; // target ratios to sample from
    const responseKeys = ['f','j']; // f = left, j = right

    // Global variables for timing and control
    let taskStartTime = null;
    let taskEndTime = null;
    let shouldStopTask = false;
    let timerInterval = null;

    // IMPORTANT: store the most recent trial spec here (stable + simple)
    let lastSpec = null;

    // Helper: uniform integer inclusive
    function rint(min, max) {
      return Math.floor(Math.random()*(max-min+1)) + min;
    }

    // Helper: random choice
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    // Fixed generateDotPositions that respects canvas boundaries and dividing line
    function generateDotPositions(count, bbox, radiiRange, minSpacing, maxAttemptsPerDot=300) {
      const dots = [];
      const maxR = radiiRange[1];
      const minR = radiiRange[0];

      const safeMinX = bbox.x + maxR;
      const safeMaxX = bbox.x + bbox.w - maxR;
      const safeMinY = bbox.y + maxR;
      const safeMaxY = bbox.y + bbox.h - maxR;

      if (safeMinX >= safeMaxX || safeMinY >= safeMaxY) {
        console.error("Bbox too small for dots of this size", bbox, radiiRange);
        return [];
      }

      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < maxAttemptsPerDot) {
          attempts++;

          const r = rint(minR, maxR);

          const minX = bbox.x + r;
          const maxX = bbox.x + bbox.w - r;
          const minY = bbox.y + r;
          const maxY = bbox.y + bbox.h - r;

          if (minX > maxX || minY > maxY) continue;

          const x = rint(Math.ceil(minX), Math.floor(maxX));
          const y = rint(Math.ceil(minY), Math.floor(maxY));

          if (x - r < bbox.x || x + r > bbox.x + bbox.w ||
              y - r < bbox.y || y + r > bbox.y + bbox.h) {
            continue;
          }

          let ok = true;
          for (const d of dots) {
            const dx = d.x - x;
            const dy = d.y - y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < (d.r + r + minSpacing)) {
              ok = false;
              break;
            }
          }

          if (ok) {
            dots.push({x, y, r});
            placed = true;
          }
        }

        if (!placed) {
          for (let relaxAttempt = 0; relaxAttempt < 20 && !placed; relaxAttempt++) {
            const r = rint(minR, maxR);
            const minX = bbox.x + r;
            const maxX = bbox.x + bbox.w - r;
            const minY = bbox.y + r;
            const maxY = bbox.y + bbox.h - r;

            if (minX > maxX || minY > maxY) continue;

            const x = rint(Math.ceil(minX), Math.floor(maxX));
            const y = rint(Math.ceil(minY), Math.floor(maxY));

            if (x - r < bbox.x || x + r > bbox.x + bbox.w ||
                y - r < bbox.y || y + r > bbox.y + bbox.h) {
              continue;
            }

            let ok = true;
            const relaxedSpacing = Math.max(0, minSpacing - relaxAttempt * 0.2);
            for (const d of dots) {
              const dx = d.x - x;
              const dy = d.y - y;
              const dist = Math.sqrt(dx*dx + dy*dy);
              if (dist < (d.r + r + relaxedSpacing)) {
                ok = false;
                break;
              }
            }

            if (ok) {
              dots.push({x, y, r});
              placed = true;
            }
          }
        }

        if (!placed) {
          const r = minR;
          const centerX = bbox.x + bbox.w / 2;
          const centerY = bbox.y + bbox.h / 2;

          if (centerX - r >= bbox.x && centerX + r <= bbox.x + bbox.w &&
              centerY - r >= bbox.y && centerY + r <= bbox.y + bbox.h) {
            dots.push({x: centerX, y: centerY, r});
          }
        }
      }

      return dots;
    }

    // Generate a single trial spec
    function makeTrial() {
      const ratio = choice(ratios);

      const baseMin = numerosityRange[0];
      const baseMax = numerosityRange[1];
      let base = rint(baseMin, baseMax);
      let larger = Math.round(base * ratio);

      if (larger < numerosityRange[0]) {
        base = Math.ceil(numerosityRange[0] / ratio);
        larger = Math.round(base * ratio);
      } else if (larger > numerosityRange[1]) {
        base = Math.floor(numerosityRange[1] / ratio);
        larger = Math.round(base * ratio);
      }

      base = Math.max(numerosityRange[0], Math.min(numerosityRange[1], base));
      larger = Math.max(numerosityRange[0], Math.min(numerosityRange[1], larger));

      const leftIsLarger = Math.random() < 0.5;
      const leftCount = leftIsLarger ? larger : base;
      const rightCount = leftIsLarger ? base : larger;

      const leftDots = generateDotPositions(leftCount, leftArea, dotRadiusRange, minDotSpacing);
      const rightDots = generateDotPositions(rightCount, rightArea, dotRadiusRange, minDotSpacing);

      return {
        leftCount,
        rightCount,
        ratio: (leftCount>rightCount) ? (leftCount / rightCount) : (rightCount / leftCount),
        largerSide: leftIsLarger ? 'left' : 'right',
        leftDots,
        rightDots
      };
    }

    function checkTimeLimit() {
      const now = Date.now();
      if (now >= taskEndTime) {
        shouldStopTask = true;
        clearInterval(timerInterval);
        jsPsych.endCurrentTimeline();
      }
    }

    function shouldContinueTask() {
      const now = Date.now();
      return !shouldStopTask && now < taskEndTime;
    }

    // Build jsPsych timeline
    const timeline = [];

    // Instructions
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `
        <h3>Approximate Number System (ANS) Task</h3>
        <p>Two dot arrays will flash briefly (left and right). After a short delay, press <strong>F</strong> if the <strong>left</strong> side had more dots, or <strong>J</strong> if the <strong>right</strong> side had more dots.</p>
        <p>Try to be both fast and accurate.</p>
        <p><strong>Duration:</strong> This task will run for ${taskDurationMinutes} minute${taskDurationMinutes > 1 ? 's' : ''}, and you will see as many trials as possible in that time.</p>
        <p><strong>Stop Button:</strong> You can stop the task at any time by clicking the red "Stop Task" button.</p>
        <p><em>Press any key to begin.</em></p>
      `,
      choices: jsPsych.ALL_KEYS,
      on_finish: function() {
        taskStartTime = Date.now();
        taskEndTime = taskStartTime + taskDurationMs;
        shouldStopTask = false;

        document.getElementById('stop-button').style.display = 'block';
        timerInterval = setInterval(checkTimeLimit, 100);

        document.getElementById('stop-button').onclick = function() {
          shouldStopTask = true;
          clearInterval(timerInterval);

          // Redirect back to Qualtrics even if they stop early (still flags it as done=0)
          const qlink = "YOUR_QUALTRICS_LINK_HERE";
          window.location.href = qlink + "?ans_done=0&pid=" + encodeURIComponent(pid);
        };
      }
    });

    const trialLoop = {
      timeline: [],
      loop_function: function() {
        return shouldContinueTask();
      }
    };

    trialLoop.timeline = [
      // fixation
      {
        type: 'html-keyboard-response',
        stimulus: '<div style="font-size:100px; display:flex; justify-content:center; align-items:center; height:50vh;">+</div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: fixationDuration,
        data: { phase: 'fixation' }
      },

      // stimulus
      {
        type: 'canvas-keyboard-response',
        canvas_size: [canvasSize.w, canvasSize.h],
        stimulus: function(c) {
          const spec = makeTrial();
          lastSpec = spec; // <- key fix

          const ctx = c.getContext('2d');
          ctx.clearRect(0,0,c.width,c.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0,0,c.width,c.height);

          ctx.strokeStyle = '#cccccc';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(c.width/2, 0);
          ctx.lineTo(c.width/2, c.height);
          ctx.stroke();

          for (const d of spec.leftDots){
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }

          for (const d of spec.rightDots){
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }
        },
        choices: jsPsych.NO_KEYS,
        trial_duration: stimDuration,
        data: { trial_type: 'stimulus' },
        on_finish: function(data) {
          if (lastSpec) {
            data.leftCount = lastSpec.leftCount;
            data.rightCount = lastSpec.rightCount;
            data.ratio = lastSpec.ratio;
            data.largerSide = lastSpec.largerSide;
          }
        }
      },

      // ISI
      {
        type: 'html-keyboard-response',
        stimulus: '<div></div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: isiDuration,
        data: { phase: 'isi' }
      },

      // response
      {
        type: 'html-keyboard-response',
        stimulus: `
          <div style="font-size:18px; text-align:center;">
            <p>Which side had more dots?</p>
            <p><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
            <p style="font-size:14px; color:gray;">Press F or J to respond.</p>
          </div>
        `,
        choices: responseKeys,
        response_ends_trial: true,
        data: { trial_type: 'response' },
        on_start: function(trial) {
          if (lastSpec) {
            trial.data.leftCount = lastSpec.leftCount;
            trial.data.rightCount = lastSpec.rightCount;
            trial.data.ratio = lastSpec.ratio;
            trial.data.largerSide = lastSpec.largerSide;
          }
        },
        on_finish: function(data) {
          const key = data.response;
          const left = data.leftCount;
          const right = data.rightCount;

          let correct = 0;
          if (left > right && key === 'f') correct = 1;
          if (right > left && key === 'j') correct = 1;

          data.accuracy = correct;
          data.choice = (key === 'f' ? 'left' : (key === 'j' ? 'right' : 'none'));
        }
      }
    ];

    timeline.push(trialLoop);

    // End screen
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `<h3>Thanks â€” task complete!</h3><p>Press any key to return to the survey.</p>`,
      choices: jsPsych.ALL_KEYS,
      on_start: function() {
        document.getElementById('stop-button').style.display = 'none';
        clearInterval(timerInterval);
      }
    });

    // Initialize jsPsych
    jsPsych.init({
      timeline: timeline,
      display_element: 'jspsych-target',
      on_finish: function() {

        // OPTIONAL: local CSV download (fine for piloting)
        jsPsych.data.localSave('csv', 'ans_data.csv');

        // Redirect back to Qualtrics
        const qlink = "YOUR_QUALTRICS_LINK_HERE";
        window.location.href = qlink + "?ans_done=1&pid=" + encodeURIComponent(pid);
      }
    });
  </script>
</body>
</html>
