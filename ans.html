<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ANS Task</title>

  <!-- jsPsych core -->
  <script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet">

  <!-- Plugins -->
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-canvas-keyboard-response.js"></script>

  <style>
    #stop-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #d9534f;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      z-index: 9999;
      display: none;
    }
    #stop-button:hover { background-color: #c9302c; }
  </style>
</head>

<body>
  <div id="jspsych-target"></div>
  <button id="stop-button">Stop Task</button>

  <script>
    // ===========================
    // Qualtrics ID hookup
    // ===========================
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('pid') || 'no_pid';

    // Attach pid to all rows
    jsPsych.data.addProperties({ pid });

    // ===========================
    // ANS Task (jsPsych)
    // ===========================

    // ---- Timing ----
    const REQUIRED_MINUTES = 1;   // required portion (always runs)
    const MAX_MINUTES = 10;       // hard cap (safety)
    const stimDuration = 1000;
    const fixationDuration = 500;
    const isiDuration = 250;

    // ---- Display ----
    const canvasSize = { w: 1200, h: 600 };
    const dividerMargin = 20;
    const leftArea = { x: 0, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };
    const rightArea = { x: (canvasSize.w/2) + dividerMargin, y: 0, w: (canvasSize.w/2) - dividerMargin, h: canvasSize.h };

    // ---- Dots ----
    const dotRadiusRange = [4, 12];
    const minDotSpacing = 2;
    const numerosityRange = [6, 40];
    const ratios = [1.1, 1.2, 1.5, 2];
    const responseKeys = ['f','j']; // f = left, j = right

    // ---- State ----
    let taskStartTime = null;
    let requiredEndTime = null;
    let hardEndTime = null;
    let shouldStopTask = false;
    let timerInterval = null;
    let lastSpec = null;

    // Helpers
    function rint(min, max) { return Math.floor(Math.random()*(max-min+1)) + min; }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function generateDotPositions(count, bbox, radiiRange, minSpacing, maxAttemptsPerDot=300) {
      const dots = [];
      const maxR = radiiRange[1];
      const minR = radiiRange[0];

      const safeMinX = bbox.x + maxR;
      const safeMaxX = bbox.x + bbox.w - maxR;
      const safeMinY = bbox.y + maxR;
      const safeMaxY = bbox.y + bbox.h - maxR;

      if (safeMinX >= safeMaxX || safeMinY >= safeMaxY) return [];

      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;

        while (!placed && attempts < maxAttemptsPerDot) {
          attempts++;
          const r = rint(minR, maxR);

          const minX = bbox.x + r;
          const maxX = bbox.x + bbox.w - r;
          const minY = bbox.y + r;
          const maxY = bbox.y + bbox.h - r;
          if (minX > maxX || minY > maxY) continue;

          const x = rint(Math.ceil(minX), Math.floor(maxX));
          const y = rint(Math.ceil(minY), Math.floor(maxY));

          let ok = true;
          for (const d of dots) {
            const dx = d.x - x, dy = d.y - y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < (d.r + r + minSpacing)) { ok = false; break; }
          }
          if (ok) { dots.push({x, y, r}); placed = true; }
        }

        if (!placed) {
          // fallback: smallest dot at center
          const r = minR;
          const cx = bbox.x + bbox.w/2;
          const cy = bbox.y + bbox.h/2;
          dots.push({x: cx, y: cy, r});
        }
      }
      return dots;
    }

    function makeTrial() {
      const ratio = choice(ratios);

      let base = rint(numerosityRange[0], numerosityRange[1]);
      let larger = Math.round(base * ratio);

      if (larger < numerosityRange[0]) {
        base = Math.ceil(numerosityRange[0] / ratio);
        larger = Math.round(base * ratio);
      } else if (larger > numerosityRange[1]) {
        base = Math.floor(numerosityRange[1] / ratio);
        larger = Math.round(base * ratio);
      }

      base = Math.max(numerosityRange[0], Math.min(numerosityRange[1], base));
      larger = Math.max(numerosityRange[0], Math.min(numerosityRange[1], larger));

      const leftIsLarger = Math.random() < 0.5;
      const leftCount = leftIsLarger ? larger : base;
      const rightCount = leftIsLarger ? base : larger;

      return {
        leftCount,
        rightCount,
        ratio: (leftCount > rightCount) ? (leftCount/rightCount) : (rightCount/leftCount),
        largerSide: leftIsLarger ? 'left' : 'right',
        leftDots: generateDotPositions(leftCount, leftArea, dotRadiusRange, minDotSpacing),
        rightDots: generateDotPositions(rightCount, rightArea, dotRadiusRange, minDotSpacing)
      };
    }

    function updateTimeChecks() {
      const now = Date.now();
      if (now >= hardEndTime) {
        shouldStopTask = true;
        clearInterval(timerInterval);
        jsPsych.endCurrentTimeline();
      }
    }

    function canContinueTrials() {
      const now = Date.now();
      return !shouldStopTask && now < hardEndTime;
    }

    function showEndMessage(extraText = "") {
      document.body.innerHTML = `
        <div style="text-align:center; margin-top:90px; font-family:Arial;">
          <h2>You’re all set!</h2>
          <p>${extraText}</p>
          <p style="color:gray; font-size:14px;">
            Please return to the Qualtrics tab and continue the survey.
          </p>
        </div>
      `;
    }

    // ===========================
    // Build timeline
    // ===========================
    const timeline = [];

    // Instructions + start
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `
        <h3>Approximate Number System (ANS) Task</h3>
        <p>Two dot arrays will flash briefly (left and right).</p>
        <p>Press <strong>F</strong> if the <strong>left</strong> side had more dots, or <strong>J</strong> if the <strong>right</strong> side had more dots.</p>
        <p><strong>Required portion:</strong> ${REQUIRED_MINUTES} minute.</p>
        <p>After that, you may choose to continue with additional optional trials or stop at any time.</p>
        <p><em>Press any key to begin.</em></p>
      `,
      choices: jsPsych.ALL_KEYS,
      on_finish: function() {
        taskStartTime = Date.now();
        requiredEndTime = taskStartTime + REQUIRED_MINUTES * 60 * 1000;
        hardEndTime = taskStartTime + MAX_MINUTES * 60 * 1000;

        shouldStopTask = false;

        document.getElementById('stop-button').style.display = 'block';

        // hard-stop safety timer
        timerInterval = setInterval(updateTimeChecks, 200);

        // Stop button ends timeline (NO redirect)
        document.getElementById('stop-button').onclick = function() {
          shouldStopTask = true;
          clearInterval(timerInterval);
          jsPsych.endCurrentTimeline(); // ends the loop cleanly
        };
      }
    });

    // Trial loop
    const trialLoop = {
      timeline: [],
      loop_function: function() { return canContinueTrials(); }
    };

    // One "trial unit"
    trialLoop.timeline = [
      // fixation
      {
        type: 'html-keyboard-response',
        stimulus: '<div style="font-size:100px; display:flex; justify-content:center; align-items:center; height:50vh;">+</div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: fixationDuration,
        data: { phase: 'fixation' }
      },
      // stimulus
      {
        type: 'canvas-keyboard-response',
        canvas_size: [canvasSize.w, canvasSize.h],
        stimulus: function(c) {
          const spec = makeTrial();
          lastSpec = spec;

          const ctx = c.getContext('2d');
          ctx.clearRect(0,0,c.width,c.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0,0,c.width,c.height);

          // divider
          ctx.strokeStyle = '#cccccc';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(c.width/2, 0);
          ctx.lineTo(c.width/2, c.height);
          ctx.stroke();

          // dots
          for (const d of spec.leftDots){
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }
          for (const d of spec.rightDots){
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(d.x, d.y, d.r, 0, 2*Math.PI);
            ctx.fill();
          }
        },
        choices: jsPsych.NO_KEYS,
        trial_duration: stimDuration,
        data: { trial_type: 'stimulus' },
        on_finish: function(data) {
          if (lastSpec) {
            data.leftCount = lastSpec.leftCount;
            data.rightCount = lastSpec.rightCount;
            data.ratio = lastSpec.ratio;
            data.largerSide = lastSpec.largerSide;
          }
        }
      },
      // isi
      {
        type: 'html-keyboard-response',
        stimulus: '<div></div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: isiDuration,
        data: { phase: 'isi' }
      },
      // response
      {
        type: 'html-keyboard-response',
        stimulus: `
          <div style="font-size:18px; text-align:center;">
            <p>Which side had more dots?</p>
            <p><strong>F</strong> = Left &nbsp;&nbsp;&nbsp; <strong>J</strong> = Right</p>
          </div>
        `,
        choices: responseKeys,
        response_ends_trial: true,
        data: { trial_type: 'response' },
        on_start: function(trial) {
          if (lastSpec) {
            trial.data.leftCount = lastSpec.leftCount;
            trial.data.rightCount = lastSpec.rightCount;
            trial.data.ratio = lastSpec.ratio;
            trial.data.largerSide = lastSpec.largerSide;
          }
        },
        on_finish: function(data) {
          const key = data.response;
          const left = data.leftCount;
          const right = data.rightCount;

          let correct = 0;
          if (left > right && key === 'f') correct = 1;
          if (right > left && key === 'j') correct = 1;

          data.accuracy = correct;
          data.choice = (key === 'f' ? 'left' : 'right');
        }
      }
    ];

    timeline.push(trialLoop);

    // Optional "continue?" prompt after required portion
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: function() {
        const now = Date.now();
        if (now < requiredEndTime && !shouldStopTask) {
          return `<p style="text-align:center;">Continuing required portion…</p>`;
        }
        return `
          <div style="text-align:center;">
            <h3>Optional continuation</h3>
            <p>You have completed the required portion.</p>
            <p>Press <strong>C</strong> to continue with more trials, or <strong>S</strong> to stop.</p>
          </div>
        `;
      },
      choices: function() {
        const now = Date.now();
        if (now < requiredEndTime && !shouldStopTask) return jsPsych.NO_KEYS;
        return ['c','s'];
      },
      trial_duration: function() {
        const now = Date.now();
        if (now < requiredEndTime && !shouldStopTask) return 10; // keep moving until required portion ends
        return null;
      },
      on_finish: function(data) {
        const now = Date.now();
        if (now < requiredEndTime && !shouldStopTask) {
          // keep going; do nothing
          data.continue_choice = 'required';
          return;
        }
        if (data.response === 's') shouldStopTask = true;
      }
    });

    // (loop back) Add another loop block by reusing trialLoop + prompt until stop/hard cap
    // Simple approach: just run the same loop again by pushing them again while allowed.
    // For jsPsych 6, easiest is: end naturally by stop/hard cap; optional prompt already sets shouldStopTask.

    // Final screen
    timeline.push({
      type: 'html-keyboard-response',
      stimulus: `<h3>Thanks — task complete!</h3><p>Press any key to finish.</p>`,
      choices: jsPsych.ALL_KEYS,
      on_start: function() {
        document.getElementById('stop-button').style.display = 'none';
        clearInterval(timerInterval);
      }
    });

    // Init
    jsPsych.init({
      timeline: timeline,
      display_element: 'jspsych-target',
      on_finish: function() {
        // Summary scores
        const responses = jsPsych.data.get().filter({ trial_type: 'response' });
        const attempted = responses.count();
        const correct = responses.filter({ accuracy: 1 }).count();
        const engagement = correct;
        const persistence = attempted > 0 ? correct / attempted : 0;

        jsPsych.data.addProperties({
          attempted, correct, engagement, persistence
        });

        // optional local save for pilots
        // jsPsych.data.localSave('csv', 'ans_data.csv');

        // End message (NO redirect)
        showEndMessage("You may now return to the survey tab.");
      }
    });
  </script>
</body>
</html>
